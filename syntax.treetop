require './helper'

grammar L
  rule main
    packages:import* other:(fun / class / statement)* {
      def to_ast
        RootNode.new(multi_to_ast(packages), multi_to_ast(other))
      end
    }
  end

  rule import
    'import' white+ quote name:identifier quote space+ {
      def to_ast
        PackageNode.new(name.to_ast)
      end
    }
  end


  rule fun
    space* 'def' white+ name:identifier white* args:fun_args? space+
    stmts:statements
    block_end {
      def to_ast
        FunNode.new(name.to_ast, optional_to_ast(args), stmts.to_ast)
      end
    }
  end

  rule fun_args
    '('
           all_args:(
           (space* identifier space*)
            (','  space* identifier space*)*
            )?
    ')' {
      def to_ast
        if optional_node_exist? all_args
          []
        else
          args.map(&:to_ast)
        end
      end

      def args
        [first_args] + after_args
      end

      def first_args
        all_args.elements[0].elements[1]
      end

      def after_args
        all_args.elements[1].elements.map{|e| e.elements[2]}
      end
    }
  end

  rule type
    'int' space+
  end

  rule fun_call
    &(identifier '(')
    name:identifier args:call_args {
      def to_ast
      begin
        FunCallNode.new(name.to_ast, args.to_ast)
      rescue => e
        p e
        debug args
      end
      end
    }
  end

  rule call_args
    '(' args:(space* expression (space* ',' space* expression)*)? ')' {
      def to_ast
        args_list = args.elements
        if args_list.nil?
          []
        else
          all_args.map(&:to_ast)
        end
      end

      def all_args
        args_list = args.elements
        ([args_list[1]] + args_list[2].elements.map {|e| e.elements[3]})
      end
    }
  end


  rule class
    space* 'class' white+ name:upper_case_name  (white+ '<' white+ parent:identifier)? space+
    define:(space / fun / class_member_var)*
    block_end {
      def to_ast
        ClassNode.new(name.to_ast, define_ast, parent.inspect)
      end

      def define_ast
        debug define
        define.elements.map do |e|
          # TODO:error, only process fun
          if e.elements.nil? or e.elements.empty?
            nil
          elsif e.elements.length == 3
            e.elements[2].to_ast
          else
            e.to_ast
          end
        end.compact
      end
    }
  end

  rule class_member_var
     'var' white+ name:identifier ('=' default_val:expression)? {
        def to_ast

        end
     }
  end

  rule statements
    stmts:(statement*) {
      def to_ast
        StatementsNode.new(multi_to_ast(stmts))
      end
    }
  end

  rule statement
    stmt_node:(break_point / variant / if / while / return / assign / expression)? space+ {
      def to_ast
        StatementNode.new(optional_to_ast(stmt_node))
      end
    }
  end

  rule break_point
    'break' {
      def to_ast
        BreakPoint.new
      end
    }
  end

  rule assign
    var:(identifier_node / class_member_access) white* '=' space* val:expression {
      def to_ast
        AssignNode.new(var.to_ast, val.to_ast)
      end
    }
  end

  rule variant
    'var' space+ name:identifier space+ '=' space+ expr:expression {
      def to_ast
        VariantNode.new(name.to_ast, expr.to_ast)
      end
    }
  end

  rule if
    'if' white+ if_cond:expression space+
    if_stmts:statements
    elsif_node:('elsif' white+ expression space+
    statements)*
    else_node:('else' space+
    statements)?
    block_end {
      def to_ast
        IfNode.new(if_cond.to_ast, if_stmts.to_ast,
          elsif_ast, else_ast)
      end

      def elsif_ast
        if elsif_node.elements.empty?
          []
        else
          elsif_node.elements.map{|e| destruct_elsif(e)}
        end
      end

      def destruct_elsif(elsif_node)
        [elsif_node.elements[2], elsif_node.elements[4]]
      end

      def else_ast
        if optional_node_exist?(else_node)
          else_node.elements[0].elements[2].to_ast
        else
          []
        end
      end
    }
  end

  rule while
    'while' white+ expression space+
    statements
    block_end
  end

  rule return
    'return' expr:expression {
      def to_ast
        ReturnNode.new(expr.to_ast)
      end
    }
  end

  rule block_end
    'end'
  end

  rule expression
    first:term after:(space* op space* term)* {
      def to_ast
        ExprNode.new(([first] + multi_term_ast).map(&:to_ast))
      end

      def multi_term_ast
        after.elements.map{|e| [e.elements[1], e.elements[3]]}.flatten
      end
    }
  end

  rule op
    op_char:('+' / '-' / '*' / '/') {
      def to_ast
        OpNode.new(text_value)
      end
    }
  end

  rule term
    term_val:(bool_constant / num_constant / string_constant /
    new_expr / class_member_access / fun_call / identifier_node) {
      def to_ast
        term_val.to_ast
      end
    }
  end

  # TODO:set args optional
  rule class_member_access
    instance_name:identifier white* '.' member_name:identifier white*
    args:call_args {
      def to_ast
        ClassMemberAccessNode.new(instance_name.to_ast, member_name.to_ast, args.to_ast)
      end
    }
  end

  rule new_expr
    # TODO: how to set '(' is optional
    # and still can distinguish between id and call
    class_name:upper_case_name  space? '.' space? 'new' space?
    args:call_args {
      def to_ast
        NewExprNode.new(class_name.to_ast, args.to_ast)
      end
    }
  end

  rule identifier_node
    name:identifier {
      def to_ast
        IdentifierNode.new(name.to_ast)
      end
    }
  end

  rule bool_constant
    constant_val:('true' / 'false') {
      def to_ast
        to_instance_node BoolConstant.new(text_value)
      end
    }
  end

  rule num_constant
    constant_val:(integer / float) {
      def to_ast
        to_instance_node NumberConstant.new(text_value)
      end
    }
  end

  rule integer
    ('+' / '-')? [0-9]+
  end

  rule float
    ('+' / '-')? [0-9]+ (('.' [0-9]+) / ('e' [0-9]+))
  end

  rule string_constant
    constant_val:(('"' ([^"\\] / "\\" . )* '"') / ("'" ([^'\\] / '\\' . )* "'")) {
      def to_ast
        to_instance_node StringConstant.new(text_value)
      end
    }
  end

  rule identifier
    !keyword name:([a-zA-Z] [a-zA-Z0-9_]*) {
      def to_ast
        text_value
      end
    }
  end

  # TODO:how to show error info
  rule upper_case_name
    !keyword &[A-Z] [a-zA-Z0-9_]* {
      def to_ast
        text_value
      end
    }
  end

  rule quote
    ['"]
  end

  rule space
    white / comment_to_eol / line_break
  end

  rule white
    [ \t]
  end

  rule line_break
    [\r\n]
  end

  rule comment_to_eol
    '#' (!"\n" .)*
  end

  rule keyword
    'class' / 'def' / 'end' / 'var' /
    'true' / 'false' /
    'if' / 'else' / 'elsif' / 'while' /
    'int' / 'new'
  end
end